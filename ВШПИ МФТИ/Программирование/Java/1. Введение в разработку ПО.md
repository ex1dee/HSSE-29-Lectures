IDE любая, желательно IntelliJ IDEA.
Можно получить лицензию.
Чат на проверку, сюда кидать ДЗ. Кидайте ссылку в чат и в гугл таблицу.


Преподаватель: **Дмитрий Бобряков**
(1 из 3 лекторов по Java).


**Разработка** - автоматизация определённого бизнес-процесса, решение проблемы.

**Статистическая типизация** гаранитирует проверку типов во время работы программы.
**Динамическая типизация** -> тип присваивается в момент назначения значения, а не в момент объявления переменной.

В Java тип объявляется **сразу.**

Плюсы статической типизации:
+ Мы уверены в значениях, которые получаем
+ Безопасность
+ Подсказки от IDE

Плюсы динамической типизации:
+ Проще учить

*Почему Java?*
+ Много вакансий, высокие зарплаты
+ Garbage collector (сборщик мусора)
+ Поддерживаемость кода (обратная совместимость, то есть не надо переписывать, если новая версия языка вышла)
+ Много фреймворков
+ Кросс-платформенность (Java Virtual Machine)

*Почему коммандная разработка важна?*
	- Много профессий и ролей, сложность каждой из компетенций
	- Скорость, параллельность разработки
	- Если человек ушёл с работы, другие продолжат поддержку проекта

Мы должны при создании проекта делать вертикальный срез, думать как дизайнер, аналитик, инженер...

**Hard skills:**
+ Знания языка, технологий

**Soft skills** ("софты"):
+ Умение коммуницировать, выражать своё мнение
+ Умение слушать других
+ Тайм-менеджмент
+ Code review (проверка кода)


## Системы контроля версий (version control systems)

Много людей работают над проектом -> нужны системы контроля версий

*Зачем нужна?*
+ Возможность отслеживать изменения (кто, когда, как их сделал)
+ Откат изменений
+ Параллельная разработка
+ Резервное копирование

Разные системы контроля версий могут хранить версии *целиком* или только *изменения.*

### Git

Создана Линусом Торвальдсом в 2005 году.

Каждый имеет полную копию (уточнить)
Можно работать с ветками у себя локально, не нужен сервер.

Философия Git: 
 + Распределённость
 + Целостность данных
 + Скорость
 + Неизменность данных (1 раз коммит сделали - больше не меняется)


Состояния файла:
- modified: изменён, не сохранены изменения

Когда коммитим файлы, создаём новую версию проекта.


*Как сделать репозиторий?*
Создаём пустой на GitHub, потом клонируем или через init (не рекомендуется)

Базовые комманды:
$ git status (Проверка статуса)

$ git add file.txt     
$ git add .      # добавить все файлы
$ git add .java   # добавить все файлы, которые оканчиваются на .java

Удалённый репозиторий 
$ git remote add origin (ссылка)

origin - псевдоним

*Просмотр удалённых изменений*
$ git remote -v

*Отправка изменений на сервер*
$ git push origin master

*Получить измнения с сервера*
$ git pull origin master



### Работа с ветками

*Создание ветки*
$ git branch feature-branch

*Переключение на ветку*
$ git checkout feature-branch
или
$ git switch feature-branch


### Типы веток

**Main/Master** - главная ветка
**Develop** - ветка для разработчика
**Feature branches** - ветки для разработки новых функций
**Release branches** - ветки для подготовки релиза
**Hotfix branches** - ветки для срочных исправлений


Не все версии из Main попадают в Release


Pull request
Draft - черновик, не хотим вливать (merge)


**Best practices:**
- частые маленькие изменения
- Осмысленные сообщения коммитов
- Одна логическая единица изменения на коммит
- Тестирование перед коммитом
- Использование .gitignore (не хранить на сервере определённый файл)

**Частые ошибки:**
 - Коммит больших бинарных файлов
 - Force push в общие ветки
 - Неполные сообщения коммитов
 - Игнорирование конфликов



### CI/CD

**Continious Integration** - процесс непрерывной интеграции изменений нескольких разработчиков в единое целое (вливание pull request-ов в master-ветку)

*Требования к Continuous Integration:*
- Код в master всегда должен компилироваться
- Тесты должны выполняться
- Все дополнительные проверки должны быть успешны (статический анализ)
CD -  Continious Delievery

CD - Continious Deployment - процесс непрерывной доставки изменений на среду развёртывания.

